<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Javascript Novice to Ninja (Ch. 10)</title>
</head>

<body>
  <main>
    <h3>Chapter 10</h3>
    <h4>Testing and Debugging</h4>
    <p>Errors, Exceptions, and Warnings</p>
    <pre>
      System error ― system or external devices with which the program is interacting.
      Programmer error ― incorrect syntax or faulty logic.
      User error ― the user has entered data incorrectly, which the program is unable to handle.
    </pre>
    <pre>
      JavaScript is a fairly forgiving language when it comes to errors; it didn’t implement exceptions at all until ECMAScript version 3. 
      Instead of alerting a user to an error in a program, it just failed silently in the background, and this is sometimes still the case.
      ECMAScript 5 introduced a strict mode that produces more exceptions and warnings and prohibits the use of some deprecated features.
      Strict mode simply requires the following string to be added to the first line of a JavaScript file:
        
        'use strict';

      You can even use strict mode on a per-function basis by adding the line inside a function. 
      Strict mode will then only be applied to anything inside that function:
        
        function strictly(){
        'use strict';
        }

      ES6 introduced JavaScript modules (covered later in chapter 15). These are selfcontained pieces of code that are in strict mode by default, so the 'use strict' declaration is not required.
      Linting tools such as JS Lint, JS Hint, and ES Lint can be used to test the quality of JavaScript code, beyond simply using strict mode.

      The most basic form of debugging is to use the alert() method to show a dialog at certain points in the code.
      Because alert() stops a program from running until OK is clicked, it allows us to effectively put breakpoints and check variables at that point.

      console.log() method can be used to log the value of variables at different stages of the program, although it won't  stop the execution of the program.
      </pre>
    <p>Debugging Tools</p>
    <pre>
      The debugger keyword will create a breakpoint in your code that will pause the execution of the code. You can also hover over any variables to see what value they hold at that point.

        function amIOldEnough(age){
          debugger;
          if (age < 12) {
            debugger; 
            return 'No, sorry.' ; 
          } else if (age < 18) { 
            debugger;
            return 'Only if you are accompanied by an adult.' ; 
          } else { debugger; 
            return 'Yep, come on in!' ; }
         }
      </pre>
    <p>Errors</p>
    <pre>
      EvalError is not used in the current ECMAScript specification and only retained for backwards compatibility. 
      RangeError is thrown when a number is outside an allowable range of values.
      ReferenceError is thrown when a reference is made to an item that doesn’t exist.
      SyntaxError is thrown when there’s an error in the code’s syntax.
      TypeError is thrown when there’s an error in the type of value used.
      URIError is thrown when there’s a problem encoding or decoding the URI.
      InternalError is a non-standard error that is thrown when an error occurs in the JavaScript engine. A common cause of this is too much recursion.
</pre>
    <p>Throwing Exceptions</p>
    <pre>
      function squareRoot(number) {
      'use strict';
      if (number < 0) {
        throw new RangeError('You cannot find the square root of negative numbers')
      }
      return Math.sqrt(number);
      };
</pre>
    <p>Exception Handling</p>
    <pre>
      function imaginarySquareRoot(number) {
      'use strict';
      let answer;
      try {
        answer = String(squareRoot(number));
      } catch(error) {
        answer = squareRoot(-number)+"i";
      } finally {
        return `+ or - ${answer}`;
        }
      }

    The code inside the catch block will only run if an exception is thrown inside the try block.
    The error object is automatically passed as a parameter to the catch block. 
    This allows us to query the error name, message and stack properties, and deal with it appropriately.
</pre>
    <p>Testing</p>
    <pre>
  Test-driven development(TDD) is the process of writing tests before any actual code.
  Steps:
    1. Write tests (that initially fail)
    2. Write code to pass the tests
    3. Refactor the code
    4. Test refactored code
    5. Write more tests for new features
    This is often referred to as the “red-green-refactor” cycle of TDD, as failing tests usually show up as red, and tests that pass show as green.
</pre>
    <p>Testing Frameworks</p>
    <pre>
  Jest (npm install -g jest);
  To run this test, simply navigate to the folder that contains the file *.test.js and enter the following command:
    jest -c {}
  </pre>
  </main>
</body>

</html>